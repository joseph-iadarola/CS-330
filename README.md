# CS-330
Computational Graphics


# How do I approach designing software
While working on this project I was able to learn new skills to make my code more modular by designing a structure that would be used throughout the program. This is something that simplified my code and made the trouble shooting phase go faster. The design process that I found worked the best was to group my custom functions into main, helper and required. The main functions were the create scene and render functions, both being called from the main function. The helper functions were the UBuild functions that generated vertices and indices for each shape. These functions have the math and where the parts of the project where I spent the most time. The required function(s) is the create mesh function where the verts and indices get sent to the GPU and each builder function used at the end of their math. There are other smaller parts of the code that were not given to me but the majority of my time was spent on the three mentioned function groups. 

# How do I approach developing programs?
My approach to developing the project came from first using resources that were given to me as a starting point before searching online for answers. Once I got my head around how to store vertices and indices correctly my main challenge was to find the correct math to get get the correct vertices coordinates. This was mostly done through iteration because curved shapes need to do the same math many times to create a smooth surface so I only needed to find how to calculate the points then make that into for loops that ran for however many times I needed it to. The most significant step that I found for my developement was when I started using a general structure for the triangle mesh that could be used for each shape. This made each following milestone easier since I could keep adding to the scene while only needing to show the completed object for that milestone.

How can computer science help me in reaching my goals?
The main thing I will take away from this course is to make my code as modular as possible. I rarely made my programs use generic objects in the past, but now I have looked back at old programs and I can see where I can simplify certain areas and variables so that they are one type that represents multiple things. It is not as bad as making two car objects have different classes for example, but I would make the mistake of thinking that I would need a new object if an exsisting object was not exactly what I needed instead of modifying to existing object slightly to fit my needs without taking away from its existing purpose.  
